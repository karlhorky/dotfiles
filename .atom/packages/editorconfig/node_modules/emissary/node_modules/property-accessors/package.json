{
  "name": "property-accessors",
  "version": "1.1.0",
  "description": "A mixin for declaring property accessors",
  "main": "lib/property-accessors",
  "scripts": {
    "test": "grunt test",
    "publish": "grunt"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/atom/property-accessors"
  },
  "keywords": [
    "property",
    "accessors",
    "metaprogramming"
  ],
  "author": {
    "name": "Nathan Sobo"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/atom/telepath/raw/master/LICENSE.md"
    }
  ],
  "bugs": {
    "url": "https://github.com/atom/property-accessors/issues"
  },
  "homepage": "http://atom.github.io/property-accessors/",
  "dependencies": {
    "mixto": "1.x",
    "harmony-collections": "git+https://github.com/Benvie/harmony-collections.git#e81b4b808359e2def9eeeabfdee69c2989e1fe96"
  },
  "devDependencies": {
    "jasmine-focused": "1.x",
    "grunt-contrib-coffee": "~0.7.0",
    "grunt-cli": "~0.1.8",
    "grunt": "~0.4.1",
    "grunt-shell": "~0.2.2",
    "grunt-coffeelint": "0.0.6",
    "rimraf": "~2.2.2"
  },
  "readme": "# Property Accessors Mixin\n\nA mixin for defining dynamic properties.\n\n## Basic Usage\n\nTo define a basic property accessor, use the `accessor` declaration. If you've\nincluded the mixin into a class, you define a prototype property by calling\n`@::accessor` on its prototype.\n\n```coffee\nPropertyAccessors = require 'property-accessors'\n\nclass Vehicle\n  PropertyAccessors.includeInto(this)\n  \n  @::accessor 'type', ->\n    get: ->\n      switch @doorCount\n        when 4 then 'sedan' # i know this isn't strictly accurate\n        when 2 then 'coupe'\n    set: (type) ->\n      switch type\n        when 'sedan' then @doorCount = 4\n        when 'coupe' then @doorCount = 2\n\ncar = new Vehicle\ncar.doorCount = 2\ncar.type # => 'coupe'\n```\n\nYou can define a class-level property by *extending* with the mixin rather than\nincluding it (which extends the prototype).\n\n```coffee\nclass Vehicle\n  PropertyAccessors.extend(this)\n  \n  @accessor 'vehicleCount', get: -> @allVehicles.length  \n```\n\nYou can just pass a single function if you only want to define a getter:\n\n```coffee\nclass Vehicle\n  PropertyAccessors.includeInto(this)\n  \n  @::accessor 'type', -> # ...\n```\n\n## Fancy Usage\n\n### Lazy Accessors\n\nLazy accessors call a function the first time a property is accessed. You are\nstill free to overwrite this value by assigning the property explicitly.\n\n```coffee\nclass ScienceLab\n  PropertyAccessors.includeInto(this)\n  \n  @::lazyAccessor 'crazyComputation', -> computeCrazyComputation()\n```\n\n### Advised Accessors\n\nAdvised accessors allow you to call code before the reading or writing of a\nproperty value. If a property is being assigned, your advice function is called\nwith the value being assigned and the old value.\n\n```coffee\nclass SpyStation\n  @advisedAccessor 'online',\n    get: -> @ensureAllSystemsNominal()\n    set: -> @ensureUserIsSpy()\n\nstation = new SpyStation\nstation.online = true # ensures user is a spy, then assigns true\nstation.online # ensures all systems are nominal, then returns true\n```\n",
  "readmeFilename": "README.md",
  "_id": "property-accessors@1.1.0",
  "_from": "property-accessors@^1.1"
}
